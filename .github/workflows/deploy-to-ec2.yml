name: CI/CD - Test and Deploy PandaCare Auth-Profile

## Run CI jobs on all branches by default
on:
  push:
    branches: [ main, develop, staging, production ]
  pull_request:
    branches: [ main, develop, staging, production ]

jobs:
  test:
    name: Run tests
    runs-on: ubuntu-22.04
    steps:
      - name: Check out the Git repository
        uses: actions/checkout@v4

      - name: Set up Java toolchain
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "gradle"

      - name: Add gradlew permission
        run: chmod +x gradlew

      - name: Run unit tests
        run: ./gradlew test

  deploy:
    runs-on: ubuntu-latest
    name: Deploy to EC2
    needs: test
    # Deploy on push to any of these branches (not just main)
    if: |
      github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/develop' ||
        github.ref == 'refs/heads/staging' ||
        github.ref == 'refs/heads/production'
      )

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          # Set environment based on branch
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-prod" >> $GITHUB_OUTPUT
            echo "log_level=WARN" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=never" >> $GITHUB_OUTPUT
            echo "hikari_min=10" >> $GITHUB_OUTPUT
            echo "hikari_max=50" >> $GITHUB_OUTPUT
            echo "memory_limit=2G" >> $GITHUB_OUTPUT
            echo "cpu_limit=1.0" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-dev" >> $GITHUB_OUTPUT
            echo "log_level=INFO" >> $GITHUB_OUTPUT
            echo "log_level_app=DEBUG" >> $GITHUB_OUTPUT
            echo "health_details=when_authorized" >> $GITHUB_OUTPUT
            echo "hikari_min=5" >> $GITHUB_OUTPUT
            echo "hikari_max=20" >> $GITHUB_OUTPUT
            echo "memory_limit=1G" >> $GITHUB_OUTPUT
            echo "cpu_limit=0.5" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-staging" >> $GITHUB_OUTPUT
            echo "log_level=INFO" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=when_authorized" >> $GITHUB_OUTPUT
            echo "hikari_min=8" >> $GITHUB_OUTPUT
            echo "hikari_max=30" >> $GITHUB_OUTPUT
            echo "memory_limit=1.5G" >> $GITHUB_OUTPUT
            echo "cpu_limit=0.75" >> $GITHUB_OUTPUT
          else
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-prod" >> $GITHUB_OUTPUT
            echo "log_level=WARN" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=never" >> $GITHUB_OUTPUT
            echo "hikari_min=10" >> $GITHUB_OUTPUT
            echo "hikari_max=50" >> $GITHUB_OUTPUT
            echo "memory_limit=2G" >> $GITHUB_OUTPUT
            echo "cpu_limit=1.0" >> $GITHUB_OUTPUT
          fi
          
          echo "🌍 Deploying to environment: ${{ steps.env.outputs.environment }}"
          echo "🗄️  Database name: ${{ steps.env.outputs.db_name }}"

      - name: Create deployment package
        run: |
          # Create a clean deployment package
          mkdir -p deployment
          
          # Copy necessary files (exclude build artifacts, logs, etc.)
          rsync -av --progress . deployment/ \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='build' \
            --exclude='.gradle' \
            --exclude='logs' \
            --exclude='*.log' \
            --exclude='*.tar.gz' \
            --exclude='deployment'
          
          # Add deployment info
          echo "BRANCH=${{ github.ref_name }}" >> deployment/.deploy-info
          echo "COMMIT=${{ github.sha }}" >> deployment/.deploy-info
          echo "ENVIRONMENT=${{ steps.env.outputs.environment }}" >> deployment/.deploy-info
          echo "DEPLOYED_AT=$(date -u)" >> deployment/.deploy-info
          
          # Create tarball
          cd deployment
          tar -czf ../pandacare-deployment.tar.gz .

      - name: Copy files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "pandacare-deployment.tar.gz"
          target: "/home/ec2-user/"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            # Navigate to home directory
            cd /home/ec2-user
            
            # Set environment variables
            BRANCH="${{ github.ref_name }}"
            ENVIRONMENT="${{ steps.env.outputs.environment }}"
            DB_NAME="${{ steps.env.outputs.db_name }}"
            
            echo "🚀 Deploying branch: $BRANCH"
            echo "🌍 Environment: $ENVIRONMENT"
            echo "🗄️  Database: $DB_NAME"
            
            # Backup current deployment (if exists)
            if [ -d "auth-profile" ]; then
              echo "🔄 Backing up current deployment..."
              sudo rm -rf "auth-profile-backup-$(date +%Y%m%d-%H%M%S)" 2>/dev/null || true
              mv auth-profile "auth-profile-backup-$(date +%Y%m%d-%H%M%S)"
            fi
            
            # Extract new deployment
            echo "📦 Extracting new deployment..."
            mkdir -p auth-profile
            cd auth-profile
            tar -xzf ../pandacare-deployment.tar.gz
            
            # Create environment file with FIXED values (no shell substitution)
            echo "⚙️  Setting up $ENVIRONMENT environment..."
            cat > .env << 'EOF'
            # Deployment Info
            BRANCH=${{ github.ref_name }}
            ENVIRONMENT=${{ steps.env.outputs.environment }}
            DEPLOYED_AT=$(date -u)
            
            # Database Configuration
            POSTGRES_DB=${{ steps.env.outputs.db_name }}
            POSTGRES_USER=pandacare_user
            POSTGRES_PASSWORD=${{ secrets.DATASOURCE_PASSWORD }}
            DATASOURCE_URL=jdbc:postgresql://postgres:5432/${{ steps.env.outputs.db_name }}
            DATASOURCE_USERNAME=pandacare_user
            DATASOURCE_PASSWORD=${{ secrets.DATASOURCE_PASSWORD }}
            
            # JWT Configuration
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_EXPIRATION_MS=${{ secrets.JWT_EXPIRATION_MS }}
            
            # Application Configuration
            SERVER_PORT=8081
            SPRING_PROFILES_ACTIVE=docker
            
            # Service Integration
            RATING_URL=http://localhost:8083
            
            # Logging Configuration
            LOGGING_LEVEL_ROOT=${{ steps.env.outputs.log_level }}
            LOGGING_LEVEL_AUTH_PROFILE=${{ steps.env.outputs.log_level_app }}
            LOGGING_FILE_NAME=/app/logs/auth-profile.log
            
            # Monitoring Configuration
            MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE=health,prometheus,metrics
            MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS=${{ steps.env.outputs.health_details }}
            MANAGEMENT_METRICS_EXPORT_PROMETHEUS_ENABLED=true
            
            # Performance Configuration
            SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE=${{ steps.env.outputs.hikari_min }}
            SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE=${{ steps.env.outputs.hikari_max }}
            CONTAINER_MEMORY_LIMIT=${{ steps.env.outputs.memory_limit }}
            CONTAINER_CPU_LIMIT=${{ steps.env.outputs.cpu_limit }}
            EOF
            
            # Remove version from docker-compose.yml to avoid warnings
            sed -i '/^version:/d' docker-compose.yml
            
            # Create logs directory
            mkdir -p logs
            
            # Stop existing services
            echo "🛑 Stopping existing services..."
            docker-compose down || true
            
            # Clean up unused Docker resources
            echo "🧹 Cleaning up Docker resources..."
            docker system prune -f || true
            
            # Build and start services
            echo "🚀 Starting services for $ENVIRONMENT environment..."
            docker-compose up --build -d
            
            # Wait for application to start
            echo "⏳ Waiting for application to start..."
            sleep 60
            
            # Health check
            echo "🏥 Performing health check..."
            max_attempts=10
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if curl -f http://localhost:8081/actuator/health > /dev/null 2>&1; then
                echo "✅ Application is healthy!"
                break
              else
                echo "⏳ Health check attempt $attempt/$max_attempts failed, retrying..."
                sleep 10
                attempt=$((attempt + 1))
              fi
            done
            
            if [ $attempt -gt $max_attempts ]; then
              echo "❌ Application failed to start properly"
              echo "📋 Recent logs:"
              docker-compose logs --tail=50 auth-profile
              exit 1
            fi
            
            # Show running containers
            echo "📊 Deployment Status:"
            docker-compose ps
            
            # Show deployment info
            echo "📋 Deployment Information:"
            cat .deploy-info 2>/dev/null || echo "No deployment info available"
            
            echo "🎉 Deployment completed successfully!"
            echo "🌍 Environment: $ENVIRONMENT"
            echo "🌿 Branch: $BRANCH"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment to EC2 completed successfully!"
            echo "🌿 Branch: ${{ github.ref_name }}"
            echo "🌍 Environment: ${{ steps.env.outputs.environment }}"
            echo "🗄️  Database: ${{ steps.env.outputs.db_name }}"
          else
            echo "❌ Deployment to EC2 failed!"
            echo "🌿 Branch: ${{ github.ref_name }}"
          fi

  cleanup:
    runs-on: ubuntu-latest
    name: Cleanup
    needs: [test, deploy]
    if: always()

    steps:
      - name: Cleanup deployment artifacts
        run: |
          echo "🧹 Cleaning up deployment artifacts..."
          # Cleanup happens automatically when runner terminates