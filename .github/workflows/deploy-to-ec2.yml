name: CI/CD - Test and Deploy PandaCare Auth-Profile

on:
  push:
    branches: [ main, develop, staging, production ]
  pull_request:
    branches: [ main, develop, staging, production ]

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
  IMAGE_NAME: pandacare-auth-profile

jobs:
  build_and_test:
    name: Build and Run tests
    runs-on: ubuntu-22.04
    steps:
      - name: Check out the Git repository
        uses: actions/checkout@v4

      - name: Set up Java toolchain
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "gradle"

      - name: Add gradlew permission
        run: chmod +x gradlew

      - name: Run unit tests
        run: ./gradlew test

      - name: Build Spring Boot JAR
        run: ./gradlew bootJar

      - name: Rename JAR for consistency
        run: |
          jar_file=$(find build/libs -name '*.jar' -type f -print -quit)
          if [[ -z "$jar_file" ]]; then
            echo "Error: No JAR file found in build/libs. Make sure './gradlew bootJar' or './gradlew build' produces a JAR."
            exit 1
          fi
          mv "$jar_file" build/libs/auth-profile.jar
          echo "Renamed JAR to auth-profile.jar"

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar-artifact
          path: build/libs/auth-profile.jar

  build_and_push_docker:
    runs-on: ubuntu-latest
    name: Build and Push Docker Image
    needs: build_and_test
    if: |
      github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/develop' ||
        github.ref == 'refs/heads/staging' ||
        github.ref == 'refs/heads/production'
      )

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar-artifact
          path: ./

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_HUB_USERNAME }}
          password: ${{ env.DOCKER_HUB_TOKEN }}

      - name: Determine Docker tag
        id: docker_tag
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "tag=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "tag=development" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "tag=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/production" ]]; then
            echo "tag=production" >> $GITHUB_OUTPUT
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
          fi

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.docker_tag.outputs.tag }}
            ${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          build-args: |
            APP_JAR=auth-profile.jar
          platforms: linux/amd64,linux/arm64

  deploy:
    runs-on: ubuntu-latest
    name: Deploy to EC2
    needs: [build_and_test, build_and_push_docker]
    if: |
      github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/develop' ||
        github.ref == 'refs/heads/staging' ||
        github.ref == 'refs/heads/production'
      )

    steps:
      - name: Checkout code (for docker-compose.yml, etc.)
        uses: actions/checkout@v4

      - name: Determine environment and Docker tag
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "docker_tag=production" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-prod" >> $GITHUB_OUTPUT
            echo "log_level=WARN" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=never" >> $GITHUB_OUTPUT
            echo "hikari_min=10" >> $GITHUB_OUTPUT
            echo "hikari_max=50" >> $GITHUB_OUTPUT
            echo "memory_limit=2G" >> $GITHUB_OUTPUT
            echo "cpu_limit=1.0" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "docker_tag=development" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-dev" >> $GITHUB_OUTPUT
            echo "log_level=INFO" >> $GITHUB_OUTPUT
            echo "log_level_app=DEBUG" >> $GITHUB_OUTPUT
            echo "health_details=when_authorized" >> $GITHUB_OUTPUT
            echo "hikari_min=5" >> $GITHUB_OUTPUT
            echo "hikari_max=20" >> $GITHUB_OUTPUT
            echo "memory_limit=1G" >> $GITHUB_OUTPUT
            echo "cpu_limit=0.5" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "docker_tag=staging" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-staging" >> $GITHUB_OUTPUT
            echo "log_level=INFO" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=when_authorized" >> $GITHUB_OUTPUT
            echo "hikari_min=8" >> $GITHUB_OUTPUT
            echo "hikari_max=30" >> $GITHUB_OUTPUT
            echo "memory_limit=1.5G" >> $GITHUB_OUTPUT
            echo "cpu_limit=0.75" >> $GITHUB_OUTPUT
          else # Default case
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "docker_tag=production" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-prod" >> $GITHUB_OUTPUT
            echo "log_level=WARN" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=never" >> $GITHUB_OUTPUT
            echo "hikari_min=10" >> $GITHUB_OUTPUT
            echo "hikari_max=50" >> $GITHUB_OUTPUT
            echo "memory_limit=2G" >> $GITHUB_OUTPUT
            echo "cpu_limit=1.0" >> $GITHUB_OUTPUT
          fi
          
          echo "rating_url=${{ secrets.RATING_SERVICE_URL }}" >> $GITHUB_OUTPUT
          
          echo "üåç Deploying to environment: ${{ steps.env.outputs.environment }}"
          echo "üê≥ Docker tag: ${{ steps.env.outputs.docker_tag }}"
          echo "üóÑÔ∏è  Database name: ${{ steps.env.outputs.db_name }}"
          echo "üì° Rating Service URL: ${{ steps.env.outputs.rating_url }}"

      - name: Prepare deployment package
        run: |
          mkdir -p deployment
          
          if [ -f "docker-compose.yml" ]; then
            cp docker-compose.yml deployment/docker-compose.yml
            echo "Copied docker-compose.yml to deployment/"
          else
            echo "Error: docker-compose.yml not found in repository root."
            exit 1
          fi
          
          if [ -d "database/init" ]; then
            mkdir -p deployment/database/init
            cp -r database/init/. deployment/database/init/
            echo "Copied database/init scripts to deployment/database/init/"
          else
            echo "No database/init directory found to copy."
          fi
          
          if [ -d "monitoring" ]; then
            mkdir -p deployment/monitoring
            cp -r monitoring/. deployment/monitoring/
            echo "Copied monitoring configuration to deployment/monitoring/"
          else
            echo "No monitoring directory found to copy."
          fi
          
          echo "BRANCH=${{ github.ref_name }}" >> deployment/.deploy-info
          echo "COMMIT=${{ github.sha }}" >> deployment/.deploy-info
          echo "ENVIRONMENT=${{ steps.env.outputs.environment }}" >> deployment/.deploy-info
          echo "DOCKER_IMAGE=${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.docker_tag }}" >> deployment/.deploy-info
          echo "DEPLOYED_AT=$(date -u)" >> deployment/.deploy-info
          
          cd deployment
          tar -czf ../pandacare-deployment.tar.gz .
          echo "Deployment package created: pandacare-deployment.tar.gz"
          cd ..
          ls -l pandacare-deployment.tar.gz

      - name: Copy files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "pandacare-deployment.tar.gz"
          target: "/home/ec2-user/"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/ec2-user
            
            APP_NAME="auth-profile"
            DEPLOYMENT_DIR="/home/ec2-user/$APP_NAME"
            BACKUP_DIR="/home/ec2-user/${APP_NAME}-backup-$(date +%Y%m%d-%H%M%S)"
            DEPLOYMENT_ARCHIVE="pandacare-deployment.tar.gz"
            DOCKER_IMAGE="${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.docker_tag }}"

            echo "üöÄ Deploying branch: ${{ github.ref_name }}"
            echo "üåç Environment: ${{ steps.env.outputs.environment }}"
            echo "üê≥ Docker Image: $DOCKER_IMAGE"
            echo "üóÑÔ∏è  Database: ${{ steps.env.outputs.db_name }}"
            echo "üì° Rating URL for .env: ${{ steps.env.outputs.rating_url }}"
            
            if [ -d "$DEPLOYMENT_DIR" ]; then
              echo "üîÑ Backing up current deployment from $DEPLOYMENT_DIR to $BACKUP_DIR..."
              mv "$DEPLOYMENT_DIR" "$BACKUP_DIR" || echo "Warning: Failed to move old deployment for backup."
            fi
            
            echo "üì¶ Creating $DEPLOYMENT_DIR and extracting $DEPLOYMENT_ARCHIVE..."
            mkdir -p "$DEPLOYMENT_DIR"
            tar -xzf "$DEPLOYMENT_ARCHIVE" -C "$DEPLOYMENT_DIR"
            
            cd "$DEPLOYMENT_DIR"
            echo "Current directory: $(pwd)"
            echo "Files in deployment directory:"
            ls -la
            
            echo "‚öôÔ∏è  Setting up ${{ steps.env.outputs.environment }} environment file (.env)..."
            cat > .env << EOF
            BRANCH=${{ github.ref_name }}
            ENVIRONMENT=${{ steps.env.outputs.environment }}
            DEPLOYED_AT=$(date -u)
            COMMIT_SHA=${{ github.sha }}
            DOCKER_IMAGE=$DOCKER_IMAGE

            POSTGRES_DB=${{ steps.env.outputs.db_name }}
            POSTGRES_USER=pandacare_user
            POSTGRES_PASSWORD=${{ secrets.DATASOURCE_PASSWORD }}
            
            DATASOURCE_URL=jdbc:postgresql://postgres:5432/${{ steps.env.outputs.db_name }}
            DATASOURCE_USERNAME=pandacare_user
            DATASOURCE_PASSWORD=${{ secrets.DATASOURCE_PASSWORD }}
            
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_EXPIRATION_MS=${{ secrets.JWT_EXPIRATION_MS }}
            
            SERVER_PORT=8081
            SPRING_PROFILES_ACTIVE=docker
            
            RATING_URL=${{ steps.env.outputs.rating_url }}
            
            LOGGING_LEVEL_ROOT=${{ steps.env.outputs.log_level }}
            LOGGING_LEVEL_AUTH_PROFILE=${{ steps.env.outputs.log_level_app }}
            LOGGING_FILE_NAME=/app/logs/auth-profile.log
            
            MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE=health,prometheus,metrics,info
            MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS=${{ steps.env.outputs.health_details }}
            MANAGEMENT_METRICS_EXPORT_PROMETHEUS_ENABLED=true
            
            SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE=${{ steps.env.outputs.hikari_min }}
            SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE=${{ steps.env.outputs.hikari_max }}
            SPRING_DATASOURCE_HIKARI_CONNECTION_TIMEOUT=30000
            
            CONTAINER_MEMORY_LIMIT=${{ steps.env.outputs.memory_limit }}
            CONTAINER_CPU_LIMIT=${{ steps.env.outputs.cpu_limit }}
            
            GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}
            EOF
            echo ".env file created."

            mkdir -p logs
            echo "'logs' directory ensured for host bind mount."
            
            echo "üõë Stopping existing services (if any)..."
            docker-compose down --remove-orphans || true
            
            echo "üßπ Cleaning up Docker resources..."
            docker system prune -af || true
            
            echo "üóÑÔ∏è Checking for corrupted database volumes..."
            if docker volume ls | grep -q "postgres_data"; then
              echo "Found existing postgres volume. Checking if it's healthy..."
              if docker run --rm -v ${APP_NAME}_postgres_data:/data alpine ls /data | grep -q postgresql.conf; then
                echo "‚úÖ Database volume appears healthy, keeping it."
              else
                echo "‚ö†Ô∏è Database volume appears corrupted, removing it..."
                docker volume rm ${APP_NAME}_postgres_data || true
              fi
            fi
            
            echo "üê≥ Pulling latest Docker image: $DOCKER_IMAGE"
            docker pull $DOCKER_IMAGE
            
            echo "üöÄ Starting services for ${{ steps.env.outputs.environment }} environment..."
            docker-compose up -d
            
            echo "üìä Checking container status..."
            docker-compose ps
            
            echo "üîç Checking PostgreSQL logs..."
            docker-compose logs postgres
            
            echo "‚è≥ Waiting for PostgreSQL to be healthy..."
            timeout=300  # 5 minutes timeout
            elapsed=0
            while [ $elapsed -lt $timeout ]; do
              if docker-compose ps postgres | grep -q "healthy"; then
                echo "‚úÖ PostgreSQL is healthy!"
                break
              elif docker-compose ps postgres | grep -q "unhealthy"; then
                echo "‚ùå PostgreSQL is unhealthy. Checking logs..."
                docker-compose logs --tail=20 postgres
                break
              else
                echo "‚è≥ Waiting for PostgreSQL health check... (${elapsed}s/${timeout}s)"
                sleep 10
                elapsed=$((elapsed + 10))
              fi
            done
            
            echo "üìä Final container status before app start:"
            docker-compose ps
            
            echo "‚è≥ Waiting for application to start..."
            sleep 60
            
            echo "üè• Performing health check on http://localhost:8081/actuator/health..."
            max_attempts=10
            attempt=1
            HEALTH_CHECK_URL="http://localhost:8081/actuator/health"

            while [ $attempt -le $max_attempts ]; do
              if curl -sf "$HEALTH_CHECK_URL" > /dev/null 2>&1; then
                echo "‚úÖ Application is healthy!"
                break
              else
                echo "‚è≥ Health check attempt $attempt/$max_attempts failed for $HEALTH_CHECK_URL, retrying..."
                sleep 15
                attempt=$((attempt + 1))
              fi
            done
            
            if [ $attempt -gt $max_attempts ]; then
              echo "‚ùå Application failed to start properly after $max_attempts attempts."
              echo "üìã Recent logs for $APP_NAME service:"
              docker-compose logs --tail=100 $APP_NAME 
              exit 1
            fi
            
            echo "üìä Deployment Status (running containers):"
            docker-compose ps
            
            echo "üìã Deployment Information from .deploy-info:"
            if [ -f ".deploy-info" ]; then
              cat .deploy-info
            else
              echo "No .deploy-info file found."
            fi
            
            echo "üéâ Deployment completed successfully!"
            echo "üåç Environment: ${{ steps.env.outputs.environment }}"
            echo "üåø Branch: ${{ github.ref_name }}"
            echo "üê≥ Docker Image: $DOCKER_IMAGE"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to EC2 for branch '${{ github.ref_name }}' to environment '${{ steps.env.outputs.environment }}' completed successfully!"
          else
            echo "‚ùå Deployment to EC2 for branch '${{ github.ref_name }}' FAILED!"
            echo "Workflow run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          fi

  cleanup:
    runs-on: ubuntu-latest
    name: Cleanup Runner
    needs: [build_and_test, build_and_push_docker, deploy]
    if: always()

    steps:
      - name: Cleanup runner workspace
        run: |
          echo "üßπ GitHub Actions runner workspace is automatically cleaned up by GitHub."