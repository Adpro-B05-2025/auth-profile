name: CI/CD - Test and Deploy PandaCare Auth-Profile (Optimized)

on:
  push:
    branches: [ main, develop, staging, production ]
  pull_request:
    branches: [ main, develop, staging, production ]

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
  IMAGE_NAME: pandacare-auth-profile

jobs:
  build_and_test:
    name: Build and Run tests
    runs-on: ubuntu-22.04
    steps:
      - name: Check out the Git repository
        uses: actions/checkout@v4

      - name: Set up Java toolchain
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: "gradle"

      - name: Add gradlew permission
        run: chmod +x gradlew

      - name: Run unit tests
        run: ./gradlew test

      - name: Build Spring Boot JAR
        run: ./gradlew bootJar

      - name: Rename JAR for consistency
        run: |
          jar_file=$(find build/libs -name '*.jar' -type f -print -quit)
          if [[ -z "$jar_file" ]]; then
            echo "Error: No JAR file found in build/libs. Make sure './gradlew bootJar' or './gradlew build' produces a JAR."
            exit 1
          fi
          mv "$jar_file" build/libs/auth-profile.jar
          echo "Renamed JAR to auth-profile.jar"

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar-artifact
          path: build/libs/auth-profile.jar

  build_and_push_docker:
    runs-on: ubuntu-latest
    name: Build and Push Docker Image
    needs: build_and_test
    if: |
      github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/develop' ||
        github.ref == 'refs/heads/staging' ||
        github.ref == 'refs/heads/production'
      )

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download JAR artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar-artifact
          path: ./

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_HUB_USERNAME }}
          password: ${{ env.DOCKER_HUB_TOKEN }}

      - name: Determine Docker tag
        id: docker_tag
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "tag=production" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "tag=development" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "tag=staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/production" ]]; then
            echo "tag=production" >> $GITHUB_OUTPUT
          else
            echo "tag=latest" >> $GITHUB_OUTPUT
          fi

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.docker_tag.outputs.tag }}
            ${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          build-args: |
            APP_JAR=auth-profile.jar
          platforms: linux/amd64,linux/arm64

  deploy:
    runs-on: ubuntu-latest
    name: Deploy to EC2
    needs: [build_and_test, build_and_push_docker]
    if: |
      github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        github.ref == 'refs/heads/develop' ||
        github.ref == 'refs/heads/staging' ||
        github.ref == 'refs/heads/production'
      )

    steps:
      - name: Checkout code (for docker-compose.yml, etc.)
        uses: actions/checkout@v4

      - name: Determine environment and Docker tag
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "docker_tag=production" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-prod" >> $GITHUB_OUTPUT
            echo "log_level=WARN" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=never" >> $GITHUB_OUTPUT
            echo "hikari_min=10" >> $GITHUB_OUTPUT
            echo "hikari_max=50" >> $GITHUB_OUTPUT
            echo "memory_limit=2G" >> $GITHUB_OUTPUT
            echo "cpu_limit=1.0" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "docker_tag=development" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-dev" >> $GITHUB_OUTPUT
            echo "log_level=INFO" >> $GITHUB_OUTPUT
            echo "log_level_app=DEBUG" >> $GITHUB_OUTPUT
            echo "health_details=when_authorized" >> $GITHUB_OUTPUT
            echo "hikari_min=5" >> $GITHUB_OUTPUT
            echo "hikari_max=20" >> $GITHUB_OUTPUT
            echo "memory_limit=1G" >> $GITHUB_OUTPUT
            echo "cpu_limit=0.5" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "docker_tag=staging" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-staging" >> $GITHUB_OUTPUT
            echo "log_level=INFO" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=when_authorized" >> $GITHUB_OUTPUT
            echo "hikari_min=8" >> $GITHUB_OUTPUT
            echo "hikari_max=30" >> $GITHUB_OUTPUT
            echo "memory_limit=1.5G" >> $GITHUB_OUTPUT
            echo "cpu_limit=0.75" >> $GITHUB_OUTPUT
          else # Default case
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "docker_tag=production" >> $GITHUB_OUTPUT
            echo "db_name=auth-profile-prod" >> $GITHUB_OUTPUT
            echo "log_level=WARN" >> $GITHUB_OUTPUT
            echo "log_level_app=INFO" >> $GITHUB_OUTPUT
            echo "health_details=never" >> $GITHUB_OUTPUT
            echo "hikari_min=10" >> $GITHUB_OUTPUT
            echo "hikari_max=50" >> $GITHUB_OUTPUT
            echo "memory_limit=2G" >> $GITHUB_OUTPUT
            echo "cpu_limit=1.0" >> $GITHUB_OUTPUT
          fi
          
          echo "rating_url=${{ secrets.RATING_SERVICE_URL }}" >> $GITHUB_OUTPUT
          
          echo "üåç Deploying to environment: ${{ steps.env.outputs.environment }}"
          echo "üê≥ Docker tag: ${{ steps.env.outputs.docker_tag }}"
          echo "üóÑÔ∏è  Database name: ${{ steps.env.outputs.db_name }}"
          echo "üì° Rating Service URL: ${{ steps.env.outputs.rating_url }}"

      - name: Prepare deployment package
        run: |
          mkdir -p deployment
          
          if [ -f "docker-compose.yml" ]; then
            cp docker-compose.yml deployment/docker-compose.yml
            echo "Copied docker-compose.yml to deployment/"
          else
            echo "Error: docker-compose.yml not found in repository root."
            exit 1
          fi
          
          if [ -d "database/init" ]; then
            mkdir -p deployment/database/init
            cp -r database/init/. deployment/database/init/
            echo "Copied database/init scripts to deployment/database/init/"
          else
            echo "No database/init directory found to copy."
          fi
          
          if [ -d "monitoring" ]; then
            mkdir -p deployment/monitoring
            cp -r monitoring/. deployment/monitoring/
            echo "Copied monitoring configuration to deployment/monitoring/"
          else
            echo "No monitoring directory found to copy."
          fi
          
          echo "BRANCH=${{ github.ref_name }}" >> deployment/.deploy-info
          echo "COMMIT=${{ github.sha }}" >> deployment/.deploy-info
          echo "ENVIRONMENT=${{ steps.env.outputs.environment }}" >> deployment/.deploy-info
          echo "DOCKER_IMAGE=${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.docker_tag }}" >> deployment/.deploy-info
          echo "DEPLOYED_AT=$(date -u)" >> deployment/.deploy-info
          
          cd deployment
          tar -czf ../pandacare-deployment.tar.gz .
          echo "Deployment package created: pandacare-deployment.tar.gz"
          cd ..
          ls -l pandacare-deployment.tar.gz

      - name: Copy files to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "pandacare-deployment.tar.gz"
          target: "/home/ec2-user/"

      - name: Deploy to EC2 (Optimized)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USERNAME }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            cd /home/ec2-user
            
            APP_NAME="auth-profile"
            DEPLOYMENT_DIR="/home/ec2-user/$APP_NAME"
            BACKUP_DIR="/home/ec2-user/${APP_NAME}-backup-$(date +%Y%m%d-%H%M%S)"
            DEPLOYMENT_ARCHIVE="pandacare-deployment.tar.gz"
            DOCKER_IMAGE="${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.docker_tag }}"
            NEW_IMAGE_SHA="${{ github.sha }}"

            echo "üöÄ OPTIMIZED DEPLOYMENT STARTING"
            echo "üåç Environment: ${{ steps.env.outputs.environment }}"
            echo "üê≥ Docker Image: $DOCKER_IMAGE"
            echo "üîÑ Commit SHA: $NEW_IMAGE_SHA"
            echo "üìÖ Deploy Time: $(date -u)"
            
            # Check if this is first deployment or update
            FIRST_DEPLOYMENT=false
            if [ ! -d "$DEPLOYMENT_DIR" ]; then
              FIRST_DEPLOYMENT=true
              echo "üÜï First deployment detected"
            else
              echo "üîÑ Update deployment detected"
            fi
            
            # Backup existing deployment if it exists
            if [ -d "$DEPLOYMENT_DIR" ] && [ "$FIRST_DEPLOYMENT" = false ]; then
              echo "üíæ Creating backup: $BACKUP_DIR"
              cp -r "$DEPLOYMENT_DIR" "$BACKUP_DIR" || echo "Warning: Failed to create backup"
            fi
            
            # Create deployment directory and extract files
            echo "üì¶ Extracting deployment package..."
            mkdir -p "$DEPLOYMENT_DIR"
            tar -xzf "$DEPLOYMENT_ARCHIVE" -C "$DEPLOYMENT_DIR"
            cd "$DEPLOYMENT_DIR"
            
            # Create environment file
            echo "‚öôÔ∏è  Creating environment configuration..."
            cat > .env << EOF
            # Deployment Info
            BRANCH=${{ github.ref_name }}
            ENVIRONMENT=${{ steps.env.outputs.environment }}
            DEPLOYED_AT=$(date -u)
            COMMIT_SHA=${{ github.sha }}
            DOCKER_IMAGE=$DOCKER_IMAGE

            # Database Configuration
            POSTGRES_DB=${{ steps.env.outputs.db_name }}
            POSTGRES_USER=pandacare_user
            POSTGRES_PASSWORD=${{ secrets.DATASOURCE_PASSWORD }}
            
            DATASOURCE_URL=jdbc:postgresql://postgres:5432/${{ steps.env.outputs.db_name }}
            DATASOURCE_USERNAME=pandacare_user
            DATASOURCE_PASSWORD=${{ secrets.DATASOURCE_PASSWORD }}
            
            # Security
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_EXPIRATION_MS=${{ secrets.JWT_EXPIRATION_MS }}
            
            # Application
            SERVER_PORT=8081
            SPRING_PROFILES_ACTIVE=docker
            RATING_URL=${{ steps.env.outputs.rating_url }}
            
            # Logging
            LOGGING_LEVEL_ROOT=${{ steps.env.outputs.log_level }}
            LOGGING_LEVEL_AUTH_PROFILE=${{ steps.env.outputs.log_level_app }}
            LOGGING_FILE_NAME=/app/logs/auth-profile.log
            
            # Monitoring
            MANAGEMENT_ENDPOINTS_WEB_EXPOSURE_INCLUDE=health,prometheus,metrics,info
            MANAGEMENT_ENDPOINT_HEALTH_SHOW_DETAILS=${{ steps.env.outputs.health_details }}
            MANAGEMENT_METRICS_EXPORT_PROMETHEUS_ENABLED=true
            
            # Database Pool
            SPRING_DATASOURCE_HIKARI_MINIMUM_IDLE=${{ steps.env.outputs.hikari_min }}
            SPRING_DATASOURCE_HIKARI_MAXIMUM_POOL_SIZE=${{ steps.env.outputs.hikari_max }}
            SPRING_DATASOURCE_HIKARI_CONNECTION_TIMEOUT=30000
            
            # Container Resources
            CONTAINER_MEMORY_LIMIT=${{ steps.env.outputs.memory_limit }}
            CONTAINER_CPU_LIMIT=${{ steps.env.outputs.cpu_limit }}
            
            # Monitoring
            GRAFANA_ADMIN_PASSWORD=${{ secrets.GRAFANA_ADMIN_PASSWORD }}
            EOF
            
            # Ensure logs directory exists
            mkdir -p logs
            
            if [ "$FIRST_DEPLOYMENT" = true ]; then
              echo "üÜï FIRST DEPLOYMENT - Starting all services"
            
              # First deployment: start everything
              echo "üê≥ Pulling all Docker images..."
              docker-compose pull
            
              echo "üöÄ Starting all services..."
              docker-compose up -d
            
              echo "‚è≥ Waiting for all services to start..."
              sleep 90
            
            else
              echo "üîÑ UPDATE DEPLOYMENT - Optimized rolling update"
            
              # Check what's currently running
              echo "üìä Current service status:"
              docker-compose ps
            
              # Pull only the new application image
              echo "üê≥ Pulling new application image: $DOCKER_IMAGE"
              docker-compose pull auth-profile
            
              # Check if application is currently running
              if docker-compose ps --services --filter "status=running" | grep -q "auth-profile"; then
                echo "üì± Application is running, performing rolling update..."
            
                # Get current application container ID for comparison
                OLD_CONTAINER_ID=$(docker-compose ps -q auth-profile)
                echo "üîç Current container ID: $OLD_CONTAINER_ID"
            
                # Perform rolling update - only recreate auth-profile
                echo "üîÑ Rolling update: recreating auth-profile service..."
                docker-compose up -d --no-deps --force-recreate auth-profile
            
                # Wait a moment for the new container to start
                sleep 10
            
                # Get new container ID
                NEW_CONTAINER_ID=$(docker-compose ps -q auth-profile)
                echo "üÜï New container ID: $NEW_CONTAINER_ID"
            
                if [ "$OLD_CONTAINER_ID" != "$NEW_CONTAINER_ID" ]; then
                  echo "‚úÖ Container successfully recreated"
                else
                  echo "‚ö†Ô∏è  Warning: Container ID unchanged, deployment may not have occurred"
                fi
            
              else
                echo "üì± Application not running, starting from scratch..."
                docker-compose up -d auth-profile
              fi
            
              # Ensure all other services are running (but don't force recreate)
              echo "üîß Ensuring all supporting services are running..."
              docker-compose up -d
            
              # Clean up old images to save space
              echo "üßπ Cleaning up old Docker images..."
              docker image prune -f --filter "until=24h" || true
            fi
            
            # Wait for application health check
            echo "üè• Waiting for application health check..."
            max_attempts=20
            attempt=1
            HEALTH_CHECK_URL="http://localhost:8081/actuator/health"

            while [ $attempt -le $max_attempts ]; do
              if curl -sf "$HEALTH_CHECK_URL" > /dev/null 2>&1; then
                echo "‚úÖ Application health check passed!"
            
                # Get health check details
                echo "üìã Health status:"
                curl -s "$HEALTH_CHECK_URL" | jq '.' || curl -s "$HEALTH_CHECK_URL"
                break
              else
                echo "‚è≥ Health check attempt $attempt/$max_attempts failed, retrying in 10s..."
                if [ $attempt -eq 5 ] || [ $attempt -eq 10 ] || [ $attempt -eq 15 ]; then
                  echo "üìã Application logs (last 20 lines):"
                  docker-compose logs --tail=20 auth-profile
                fi
                sleep 10
                attempt=$((attempt + 1))
              fi
            done
            
            if [ $attempt -gt $max_attempts ]; then
              echo "‚ùå Application failed to pass health check after $max_attempts attempts"
              echo "üìã Final application logs:"
              docker-compose logs --tail=50 auth-profile
              echo "üìä Service status:"
              docker-compose ps
              exit 1
            fi
            
            # Verify service status
            echo "üìä Final service status:"
            docker-compose ps
            
            # Check which containers were actually recreated
            echo "üîç Container creation times:"
            for service in auth-profile postgres prometheus grafana; do
              if docker-compose ps $service | grep -q "Up"; then
                created_time=$(docker inspect $(docker-compose ps -q $service) | jq -r '.[0].Created' | cut -d'T' -f1,2 | tr 'T' ' ')
                echo "  $service: $created_time"
              fi
            done
            
            # Performance verification
            echo "‚ö° Performance check:"
            response_time=$(curl -w "%{time_total}" -s -o /dev/null "http://localhost:8081/actuator/health")
            echo "  Health endpoint response time: ${response_time}s"
            
            # Memory usage check
            echo "üíæ Container resource usage:"
            docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}" $(docker-compose ps -q) | head -10
            
            echo ""
            echo "üéâ OPTIMIZED DEPLOYMENT COMPLETED SUCCESSFULLY!"
            echo "‚ú® Benefits achieved:"
            if [ "$FIRST_DEPLOYMENT" = false ]; then
              echo "  üöÄ Faster deployment (only app container recreated)"
              echo "  üìä Monitoring continuity maintained"
              echo "  üóÑÔ∏è  Database connections preserved"
              echo "  üîß Zero downtime for supporting services"
            fi
            echo "  üåç Environment: ${{ steps.env.outputs.environment }}"
            echo "  üê≥ Image: $DOCKER_IMAGE"
            echo "  üìÖ Deployed at: $(date -u)"

      - name: Deployment Summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "## ‚úÖ Optimized Deployment Successful! üöÄ" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment:** ${{ steps.env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
            echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
            echo "**Docker Image:** ${{ env.DOCKER_HUB_USERNAME }}/${{ env.IMAGE_NAME }}:${{ steps.env.outputs.docker_tag }}" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üéØ Optimization Benefits:" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Only application container recreated" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Database and monitoring services preserved" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Faster deployment time" >> $GITHUB_STEP_SUMMARY
            echo "- ‚úÖ Zero downtime for supporting services" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Application URL:** http://your-ec2-ip:8081" >> $GITHUB_STEP_SUMMARY
            echo "**Health Check:** http://your-ec2-ip:8081/actuator/health" >> $GITHUB_STEP_SUMMARY
            echo "**Monitoring:** http://your-ec2-ip:3000" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Deployment Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Please check the deployment logs for details." >> $GITHUB_STEP_SUMMARY
            echo "**Workflow:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          fi

  cleanup:
    runs-on: ubuntu-latest
    name: Cleanup Runner
    needs: [build_and_test, build_and_push_docker, deploy]
    if: always()

    steps:
      - name: Cleanup runner workspace
        run: |
          echo "üßπ GitHub Actions runner workspace cleanup completed automatically."